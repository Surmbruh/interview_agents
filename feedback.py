from state import AgentState
from utils.report import generate_final_report, generate_development_roadmap
from utils.logger import LoggerUtils
from langchain_core.messages import AIMessage
from langchain_community.tools import DuckDuckGoSearchRun
import json
import concurrent.futures

def feedback_node(state: AgentState):
    """
    Generates the final report, performs bonus web search for roadmap, 
    and saves the log.
    """
    print("--- Generating Feedback (Including Bonus Search) ---")
    
    # 1. Generate core report (Manager Decision + Technical Review)
    # This uses the logic we already built in utils/report.py
    # We will invoke it, but we might want to intercept the roadmap part to add links.
    
    # Let's import the specific generators to have more control
    from utils.report import generate_technical_report
    from langchain_openai import ChatOpenAI
    from config import settings
    
    api_base = settings.OPENAI_API_BASE
    llm = ChatOpenAI(model=settings.MODEL_INTERVIEWER, temperature=0, base_url=api_base)
    
    # A. Manager Decision
    from agents.manager import ManagerAgent
    manager = ManagerAgent(llm)
    manager_decision = manager.evaluate(state)
    manager_report = manager.format_decision_report(manager_decision)
    
    # B. Technical Review
    technical_report = generate_technical_report(state, llm)
    
    # C. Roadmap + Bonus Search
    # First, identify gaps from internal thoughts
    internal_thoughts = state.get("internal_thoughts", [])
    gaps = []
    for thought in internal_thoughts:
        if isinstance(thought, dict):
            decision = thought.get("decision", "")
            if decision in ["DECREASE_DIFFICULTY", "MAINTAIN"]:
                analysis = thought.get("analysis", "")
                if analysis:
                    gaps.append(analysis)
    
    # Perform Search for Gaps (BONUS)
    search_tool = DuckDuckGoSearchRun()
    links_section = ""
    
    if gaps:
        print("    üîé Searching for learning resources (Bonus)...")
        # Limit to top 3 gaps to save time
        top_gaps = gaps[:3] 
        links = []
        
        def search_gap(gap_text):
            try:
                # Extract keywords implicitly by searching the gap description
                # We can ask LLM to summarize gap into query, but for speed let's just search the main topic + "tutorial"
                # A simple heuristic: search the analysis text limitation
                query = f"guide tutorial documentation {gap_text[:50]}"
                res = search_tool.invoke(query)
                return f"- **Context**: {gap_text[:100]}...\n  - **Resources**: {res[:200]}..." 
            except Exception:
                return None

        with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
            future_to_gap = {executor.submit(search_gap, gap): gap for gap in top_gaps}
            for future in concurrent.futures.as_completed(future_to_gap):
                result = future.result()
                if result:
                    links.append(result)
        
        if links:
            links_section = "### üîó –†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã (Auto-Generated)\n" + "\n".join(links)
    
    # Generate Roadmap Text
    roadmap_core = generate_development_roadmap(state, llm)
    
    # Append content
    full_report = f"""
# üìã –û—Ç—á—ë—Ç –ø–æ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–º—É –∏–Ω—Ç–µ—Ä–≤—å—é

## üë§ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–∞–Ω–¥–∏–¥–∞—Ç–µ
- **–ò–º—è**: {state['candidate_info'].get('Name', 'N/A')}
- **–ü–æ–∑–∏—Ü–∏—è**: {state['candidate_info'].get('Position', 'N/A')}
- **–ì—Ä–µ–π–¥**: {state['candidate_info'].get('Grade', 'N/A')}

{manager_report}

{technical_report}

{roadmap_core}

{links_section}

---
*Generated by Multi-Agent Interview Coach with Live Search*
"""

    # Save log
    candidate_name = state["candidate_info"].get("Name", "Candidate")
    LoggerUtils.save_log(candidate_name, state["interview_log"], full_report)
    
    print("\n" + "="*30)
    print("FINAL FEEDBACK REPORT")
    print("="*30)
    print(full_report)
    
    return {"messages": [AIMessage(content="INTERVIEW_FINISHED")]}
